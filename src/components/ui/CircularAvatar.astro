---
import { themeConfig } from '@/config'

interface Props {
  imageSrc?: string;
  text?: string;
  size?: number;
  duration?: number;
}

const {
  imageSrc = '/assets/alex-logo-the-conversion-dev.png',
  // text = 'ALEX GRONMARK • CONVERSION • ',
  text = 'THE CONVERSION DEV • THE CONVERSION DEV • ',
  size = 110,
  duration = 32
} = Astro.props;

const textRadius = size / 2 + 10;
const svgSize = size + 40;
---

<div class="circular-avatar" data-duration={duration} style={`--size: ${size}px; --svg-size: ${svgSize}px;`}>
  <img
    src={imageSrc}
    alt="Profile"
    class="avatar-image"
    width={size}
    height={size}
  />
  <svg
    class="rotating-text"
    viewBox={`0 0 ${svgSize} ${svgSize}`}
    width={svgSize}
    height={svgSize}
  >
    <defs>
      <path
        id="textCircle"
        d={`M ${svgSize / 2}, ${svgSize / 2} m -${textRadius}, 0 a ${textRadius},${textRadius} 0 1,1 ${textRadius * 2},0 a ${textRadius},${textRadius} 0 1,1 -${textRadius * 2},0`}
        fill="none"
      />
    </defs>
    <text class="circular-text">
      <textPath href="#textCircle" startOffset="0%">
        {text}{text}
      </textPath>
    </text>
  </svg>
</div>

<script>
  import gsap from 'gsap';

  // Module variable persists across View Transitions navigations
  let hasInitialized = false;

  function initCircularAvatar() {
    const container = document.querySelector('.circular-avatar') as HTMLElement;
    const img = container?.querySelector('.avatar-image') as HTMLElement;
    const svg = container?.querySelector('.rotating-text') as SVGElement;
    if (!container || !img || !svg) return;

    const rotationDuration = parseFloat(container.dataset.duration || '32');
    const isMobile = window.innerWidth < 768;
    const isFirstLoad = !hasInitialized;
    hasInitialized = true;

    if (isMobile || !isFirstLoad) {
      // Mobile or navigation: no entrance animation, just show and rotate
      gsap.set(img, { opacity: 1 });
      gsap.set(svg, { opacity: 1 });
      gsap.to(svg, {
        rotation: 360,
        duration: rotationDuration,
        ease: 'none',
        repeat: -1,
        transformOrigin: 'center center'
      });
    } else {
      // Desktop first load: bouncy entrance animation
      const tl = gsap.timeline();

      tl.fromTo(img,
        { scale: 0, opacity: 0 },
        { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out(1.7)', delay: 1.8 }
      );

      tl.fromTo(svg,
        { scale: 0, opacity: 0 },
        { scale: 1, opacity: 1, duration: 0.4, ease: 'back.out(2)' },
        '-=0.4'
      );

      tl.to(svg, {
        rotation: 360,
        duration: rotationDuration,
        ease: 'none',
        repeat: -1,
        transformOrigin: 'center center'
      }, '-=0.3');
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCircularAvatar);
  } else {
    initCircularAvatar();
  }

  document.addEventListener('astro:page-load', initCircularAvatar);
</script>

<script
  is:inline
  define:vars={{
    contentWidth: themeConfig.general.contentWidth,
    centeredLayout: themeConfig.general.centeredLayout,
    logo: themeConfig.general.activeLogo
  }}
>
  ;(function () {
    function adjustAvatarPosition() {
      const avatar = document.querySelector('.circular-avatar')
      if (!avatar) return

      // If not using centered layout, remove fixed positioning
      if (!centeredLayout) {
        avatar.classList.remove('fixed-position')
        avatar.style.left = ''
        return
      }

      // Calculate available margin space for positioning
      const pageWidth = window.innerWidth
      const contentWidthValue = parseFloat(contentWidth)
      const widthValue = Math.min(contentWidthValue, 50)
      const shouldUseCustomWidth = widthValue > 25
      const finalWidthValue = shouldUseCustomWidth ? widthValue : 25
      const margin = (pageWidth - finalWidthValue * 12) / 2
      const baseMinSpace = 14 * 16 // More space needed for avatar
      const minSpace = logo ? baseMinSpace + 52 : baseMinSpace + 12

      // Position avatar fixed on the left if there's enough space
      if (margin >= minSpace) {
        avatar.classList.add('fixed-position')
        const basePosition = margin - baseMinSpace
        const leftPosition = logo ? basePosition - 40 : basePosition
        avatar.style.left = `${leftPosition}px`
      } else {
        avatar.classList.remove('fixed-position')
        avatar.style.left = ''
      }
    }

    adjustAvatarPosition()

    document.addEventListener('astro:page-load', () => {
      adjustAvatarPosition()
    })
    document.addEventListener('DOMContentLoaded', () => {
      adjustAvatarPosition()
    })
    window.addEventListener('resize', adjustAvatarPosition)
  })()
</script>

<style>
  .circular-avatar {
    position: relative;
    width: var(--svg-size);
    height: var(--svg-size);
    display: flex;
    align-items: center;
    justify-content: center;
    /* margin: 0 auto 2rem auto; */
    margin-block: 2rem;
  }

  .avatar-image {
    width: var(--size);
    height: var(--size);
    border-radius: 50%;
    object-fit: cover;
    position: absolute;
    inset: 0;
    margin: auto;
    opacity: 0;
  }

  .rotating-text {
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
  }

  .circular-text {
    font-family: var(--sans);
    font-size: 0.54rem;
    font-weight: var(--font-weight-regular);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    fill: var(--text-secondary);
  }

  @media (prefers-reduced-motion: reduce) {
    .rotating-text {
      animation: none !important;
    }
  }

  .circular-avatar.fixed-position {
    position: fixed;
    top: 6rem;
    margin-block: 0;
    z-index: 10;
  }
</style>
